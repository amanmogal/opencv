## V4D OpenCV Module
The V4D OpenCV module is a library that integrates OpenCV functionalities with V4D, a framework for creating graphical applications with multiple contexts and parallel execution.

### Overview
The V4D OpenCV module allows users to perform image processing, computer vision, and machine learning tasks on video inputs and outputs using OpenCV functions and classes, and to visualize the results using V4D contexts such as OpenGL, NanoVG, and ImGui.

The V4D OpenCV module uses a graph-based pipelining approach to parallelize the execution of different tasks on multiple instances of V4D as workers. The graph is inferred from the context calls in the setup, infer, and teardown functions of the Plan class. Each context call emits a graph node that contains the functor, the l-value references to the parameters, and the underlying context it needs active when being called. After the graph has been inferred from the plan, V4D executes the graph in parallel using multiple instances of Plan as workers. Each worker has its own instance of Plan and therefore its own graph. This way, data races are only possible if a global variable or a static member of the plan is accessed. For such shared variables, there are synchronization facilities that V4D provides, such as Global::registerShared and Global::safe_copy.

### Getting Started
To create a graphical application with V4D and OpenCV, you need to create a V4D object and a Plan object, and run them in parallel with multiple workers. A V4D object is the central object to perform visualizations with. It represents a window or an offscreen buffer that can display video frames using different contexts, such as OpenGL, NanoVG, and ImGui. A V4D object also manages the parallel execution of the graph nodes that are emitted by the context calls. A Plan object is a base class for defining graphical applications with V4D and OpenCV. It inherits from v4d::Plan and overrides the setup, infer, and teardown methods. It also provides a gui method for creating a user interface with ImGui. A Plan object defines the parameters, the data structures, the computations, and the rendering operations that are performed on the video frames.

### Using the Contexts and Methods
The V4D API provides various contexts and methods to perform various tasks on the video frames, such as processing, rendering, capturing, writing, and displaying. The V4D API provides various contexts for different purposes, such as FrameBufferContext, SourceContext, SinkContext, NanoVGContext, ImGuiContext, OnceContext, PlainContext, and GLContext. Each context has its own methods and attributes, and can be accessed using the corresponding methods of the V4D object, such as fbCtx(), sourceCtx(), sinkCtx(), nvgCtx(), imguiCtx(), onceCtx(), plainCtx(), and glCtx().

The FrameBufferContext is the main context that holds the framebuffer that is displayed in the window or the offscreen buffer. It also provides methods for copying to and from the framebuffer, such as copyTo(), copyFrom(), and feed(). It also provides access to the OpenGL texture and the OpenCL context that are associated with the framebuffer. The fb() method of the V4D object can be used to emit a graph node that performs some operation on the framebuffer, such as drawing, blending, or filtering. The fb() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the operation to be performed on the framebuffer, and the references define the dependencies or outputs of the operation.

The SourceContext is the context that handles the video input from a source, such as a file, a camera, or a network stream. It provides methods for capturing and decoding the video frames, such as capture() and decode(). It also provides access to the source buffer that holds the current video frame. The capture() method of the V4D object can be used to emit a graph node that performs some operation on the source buffer, such as processing, converting, or copying. The capture() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the operation to be performed on the source buffer, and the references define the dependencies or outputs of the operation.

The SinkContext is the context that handles the video output to a sink, such as a file, a screen, or a network stream. It provides methods for encoding and writing the video frames, such as encode() and write(). It also provides access to the sink buffer that holds the current video frame. The write() method of the V4D object can be used to emit a graph node that performs some operation on the sink buffer, such as processing, converting, or copying. The write() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the operation to be performed on the sink buffer, and the references define the dependencies or outputs of the operation.

The NanoVGContext is the context that allows users to draw vector graphics using the NanoVG library. It provides methods for creating and manipulating paths, shapes, colors, gradients, fonts, and text. It also provides access to the NanoVG context that is associated with the framebuffer. The nvg() method of the V4D object can be used to emit a graph node that performs some drawing operation using the NanoVG context, such as creating a path, filling a shape, or rendering a text. The nvg() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the drawing operation to be performed using the NanoVG context, and the references define the dependencies or outputs of the operation.

The ImGuiContext is the context that allows users to create a user interface using the ImGui library. It provides methods for creating and manipulating widgets, such as buttons, sliders, checkboxes, menus, and dialogs. It also provides access to the ImGui context that is associated with the framebuffer. The imgui() method of the V4D object can be used to emit a graph node that performs some user interface operation using the ImGui context, such as creating a widget, handling an input, or displaying a message. The imgui() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the user interface operation to be performed using the ImGui context, and the references define the dependencies or outputs of the operation.

The OnceContext is the context that allows users to perform some operation only once, such as initializing some data structures, loading some resources, or printing some information. It provides methods for checking and setting the execution flag, such as isExecuted() and setExecuted(). It also provides access to the OnceContext object that is associated with the plan. The once() method of the V4D object can be used to emit a graph node that performs some operation only once, such as initializing some data structures, loading some resources, or printing some information. The once() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the operation to be performed only once, and the references define the dependencies or outputs of the operation.

The PlainContext is the context that allows users to perform some operation without any specific context, such as setting some parameters, creating some data structures, or calling some functions. It provides methods for accessing the plain context object, such as get() and set(). It also provides access to the PlainContext object that is associated with the plan. The plain() method of the V4D object can be used to emit a graph node that performs some operation without any specific context, such as setting some parameters, creating some data structures, or calling some functions. The plain() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the operation to be performed without any specific context, and the references define the dependencies or outputs of the operation.

The GLContext is the context that allows users to perform some operation using the OpenGL context, such as creating and manipulating textures, buffers, shaders, and programs. It provides methods for accessing the OpenGL context object, such as get() and set(). It also provides access to the GLContext object that is associated with the framebuffer. The gl() method of the V4D object can be used to emit a graph node that performs some operation using the OpenGL context, such as creating and manipulating textures, buffers, shaders, and programs. The gl() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines the operation to be performed using the OpenGL context, and the references define the dependencies or outputs of the operation.

### Using the Branches and Predicates
The V4D API also provides some methods for creating branches and sub-branches in the graph, and optionally pinning them to specific workers. The branch() and endbranch() methods can be used to create branches and sub-branches in the graph, and optionally pin them to specific workers. The branch() method takes a stateless lambda as the first argument, and optionally some l-value references as the following arguments. The lambda defines a predicate function that returns a boolean value, and the references define the dependencies of the predicate. The branch() method emits a graph node that evaluates the predicate and enables or disables the following nodes until the next endbranch() node. The endbranch() method takes no arguments and emits a graph node that ends the current branch or sub-branch. The branch() and endbranch() methods can be nested to create sub-branches within branches. The branch() method can also take an integer as the first argument, which specifies the worker index to pin the branch to. This means that the branch will only be executed if the current worker index matches the specified index. This can be useful for creating worker-specific tasks or data structures.

The V4D API also provides some predefined branch predicates, such as always_, isTrue_, isFalse_, and_, and or_. These predicates can be used to control the execution flow of the graph nodes based on some boolean conditions. The always_ predicate always returns true, the isTrue_ predicate returns the value of a boolean reference, the isFalse_ predicate returns the negation of a boolean reference, the and_ predicate returns the logical and of two boolean references, and the or_ predicate returns the logical or of two boolean references.

### Using the Other Features
The V4D OpenCV module also provides some other features that can enhance the graphical applications, such as displaying the framerate, printing the system information and setting the window properties. The V4D object has some methods and attributes that can control the display of the framerate, such as getShowFPS(), setShowFPS(), getPrintFPS(), and setPrintFPS(). The V4D object also has a method called printSystemInfo() that can print some basic system information to the standard error, such as the OpenGL version, the OpenCL version, the NanoVG version, and the ImGui version. The V4D object also has some methods and attributes that can control the window properties, such as position(), size(), setSize(), isFullscreen(), setFullscreen(), isResizable(), setResizable(), isVisible(), setVisible(), isStretching(), and setStretching(). The stretching mode determines if the framebuffer is scaled during blitting to fit the window size.

### Creating a Graphical Application with V4D and OpenCV
To create a graphical application with V4D and OpenCV, we need to follow these steps:

Include the header file "v4d.hpp" in our source code and link the library "opencv_v4d" in our project.
Create a V4D object and a Plan object to run them in parallel with multiple workers.
Define the setup, infer, and teardown methods of the Plan object, and use the context calls of the V4D object to emit graph nodes that perform various tasks on the video frames.
Use the branch and endbranch methods of the V4D object to create branches and sub-branches in the graph, and optionally pin them to specific workers.
Use the OpenCV functions and classes within the context calls or the lambdas of the V4D object to perform image processing, computer vision, and machine learning tasks on the video frames.
Use the helper functions and classes of the V4D OpenCV module to simplify the usage of the OpenCV functions and classes, such as makeCaptureSource, makeWriterSink, colorConvert, and Global::Scope.

Conclusion The V4D OpenCV module is a powerful and flexible library that allows users to create graphical applications with multiple contexts and parallel execution using OpenCV functions and classes. The V4D OpenCV module provides various contexts and methods for performing and visualizing various tasks on the video frames, such as processing, rendering, capturing, writing, and displaying. The V4D OpenCV module also provides some methods for creating branches and sub-branches in the graph, and optionally pinning them to specific workers. The V4D OpenCV module also provides some helper functions and classes that simplify the usage of the OpenCV functions and classes, such as makeCaptureSource, makeWriterSink, colorConvert, and Global::Scope. The V4D OpenCV module enables users to create graphical applications with V4D and OpenCV in a simple and intuitive way, by defining a Plan object and using the context calls of the V4D object. The V4D OpenCV module is a library that integrates OpenCV functionalities with V4D, a framework for creating graphical applications with multiple contexts and parallel execution.
